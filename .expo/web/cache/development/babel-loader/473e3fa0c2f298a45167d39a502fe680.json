{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Image from \"react-native-web/dist/exports/Image\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { assertStatusValuesInBounds, getNativeSourceAndFullInitialStatusForLoadAsync, getNativeSourceFromSource, getUnloadedStatus, PlaybackMixin } from \"./AV\";\nimport ExpoVideoManager from \"./ExpoVideoManager\";\nimport ExponentAV from \"./ExponentAV\";\nimport ExponentVideo from \"./ExponentVideo\";\nimport { ResizeMode } from \"./Video.types\";\n\nvar _STYLES = StyleSheet.create({\n  base: {\n    overflow: 'hidden'\n  },\n  poster: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    resizeMode: 'contain'\n  },\n  video: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  }\n});\n\nvar ExpoVideoManagerConstants = ExpoVideoManager;\nvar ExpoVideoViewManager = ExpoVideoManager;\n\nvar Video = function (_React$Component) {\n  _inherits(Video, _React$Component);\n\n  var _super = _createSuper(Video);\n\n  function Video(props) {\n    var _this;\n\n    _classCallCheck(this, Video);\n\n    _this = _super.call(this, props);\n    _this._nativeRef = React.createRef();\n    _this._onPlaybackStatusUpdate = null;\n\n    _this._handleNewStatus = function (status) {\n      if (_this.state.showPoster && status.isLoaded && (status.isPlaying || status.positionMillis !== 0)) {\n        _this.setState({\n          showPoster: false\n        });\n      }\n\n      if (_this.props.onPlaybackStatusUpdate) {\n        _this.props.onPlaybackStatusUpdate(status);\n      }\n\n      if (_this._onPlaybackStatusUpdate) {\n        _this._onPlaybackStatusUpdate(status);\n      }\n    };\n\n    _this._performOperationAndHandleStatusAsync = function () {\n      var _ref = _asyncToGenerator(function* (operation) {\n        var video = _this._nativeRef.current;\n\n        if (!video) {\n          throw new Error(\"Cannot complete operation because the Video component has not yet loaded\");\n        }\n\n        var handle = findNodeHandle(_this._nativeRef.current);\n        var status = yield operation(handle);\n\n        _this._handleNewStatus(status);\n\n        return status;\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    _this._setFullscreen = function () {\n      var _ref2 = _asyncToGenerator(function* (value) {\n        return _this._performOperationAndHandleStatusAsync(function (tag) {\n          return ExpoVideoViewManager.setFullscreen(tag, value);\n        });\n      });\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    _this.presentFullscreenPlayer = _asyncToGenerator(function* () {\n      return _this._setFullscreen(true);\n    });\n    _this.dismissFullscreenPlayer = _asyncToGenerator(function* () {\n      return _this._setFullscreen(false);\n    });\n    _this.getStatusAsync = _asyncToGenerator(function* () {\n      return _this._performOperationAndHandleStatusAsync(function (tag) {\n        return ExponentAV.getStatusForVideo(tag);\n      });\n    });\n\n    _this.loadAsync = function () {\n      var _ref6 = _asyncToGenerator(function* (source) {\n        var initialStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var downloadFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        var _yield$getNativeSourc = yield getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst),\n            nativeSource = _yield$getNativeSourc.nativeSource,\n            fullInitialStatus = _yield$getNativeSourc.fullInitialStatus;\n\n        return _this._performOperationAndHandleStatusAsync(function (tag) {\n          return ExponentAV.loadForVideo(tag, nativeSource, fullInitialStatus);\n        });\n      });\n\n      return function (_x3) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n\n    _this.unloadAsync = _asyncToGenerator(function* () {\n      return _this._performOperationAndHandleStatusAsync(function (tag) {\n        return ExponentAV.unloadForVideo(tag);\n      });\n    });\n\n    _this.setStatusAsync = function () {\n      var _ref8 = _asyncToGenerator(function* (status) {\n        assertStatusValuesInBounds(status);\n        return _this._performOperationAndHandleStatusAsync(function (tag) {\n          return ExponentAV.setStatusForVideo(tag, status);\n        });\n      });\n\n      return function (_x4) {\n        return _ref8.apply(this, arguments);\n      };\n    }();\n\n    _this.replayAsync = _asyncToGenerator(function* () {\n      var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (status.positionMillis && status.positionMillis !== 0) {\n        throw new Error('Requested position after replay has to be 0.');\n      }\n\n      return _this._performOperationAndHandleStatusAsync(function (tag) {\n        return ExponentAV.replayVideo(tag, _objectSpread(_objectSpread({}, status), {}, {\n          positionMillis: 0,\n          shouldPlay: true\n        }));\n      });\n    });\n\n    _this._nativeOnPlaybackStatusUpdate = function (event) {\n      _this._handleNewStatus(event.nativeEvent);\n    };\n\n    _this._nativeOnLoadStart = function () {\n      if (_this.props.onLoadStart) {\n        _this.props.onLoadStart();\n      }\n    };\n\n    _this._nativeOnLoad = function (event) {\n      if (_this.props.onLoad) {\n        _this.props.onLoad(event.nativeEvent);\n      }\n\n      _this._handleNewStatus(event.nativeEvent);\n    };\n\n    _this._nativeOnError = function (event) {\n      var error = event.nativeEvent.error;\n\n      if (_this.props.onError) {\n        _this.props.onError(error);\n      }\n\n      _this._handleNewStatus(getUnloadedStatus(error));\n    };\n\n    _this._nativeOnReadyForDisplay = function (event) {\n      if (_this.props.onReadyForDisplay) {\n        _this.props.onReadyForDisplay(event.nativeEvent);\n      }\n    };\n\n    _this._nativeOnFullscreenUpdate = function (event) {\n      if (_this.props.onFullscreenUpdate) {\n        _this.props.onFullscreenUpdate(event.nativeEvent);\n      }\n    };\n\n    _this._renderPoster = function () {\n      return _this.props.usePoster && _this.state.showPoster ? React.createElement(Image, {\n        style: [_STYLES.poster, _this.props.posterStyle],\n        source: _this.props.posterSource\n      }) : null;\n    };\n\n    _this.state = {\n      showPoster: !!props.usePoster\n    };\n    return _this;\n  }\n\n  _createClass(Video, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(nativeProps) {\n      var nativeVideo = this._nativeRef.current;\n      if (!nativeVideo) throw new Error(\"native video reference is not defined.\");\n      nativeVideo.setNativeProps(nativeProps);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.unloadAsync().catch(function () {});\n    }\n  }, {\n    key: \"setOnPlaybackStatusUpdate\",\n    value: function setOnPlaybackStatusUpdate(onPlaybackStatusUpdate) {\n      this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var source = getNativeSourceFromSource(this.props.source) || undefined;\n      var nativeResizeMode = ExpoVideoManagerConstants.ScaleNone;\n\n      if (this.props.resizeMode) {\n        var resizeMode = this.props.resizeMode;\n\n        if (resizeMode === ResizeMode.STRETCH) {\n          nativeResizeMode = ExpoVideoManagerConstants.ScaleToFill;\n        } else if (resizeMode === ResizeMode.CONTAIN) {\n          nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFit;\n        } else if (resizeMode === ResizeMode.COVER) {\n          nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFill;\n        }\n      }\n\n      var status = _objectSpread({}, this.props.status);\n\n      ['progressUpdateIntervalMillis', 'positionMillis', 'shouldPlay', 'rate', 'shouldCorrectPitch', 'volume', 'isMuted', 'isLooping'].forEach(function (prop) {\n        if (prop in _this2.props) {\n          status[prop] = _this2.props[prop];\n        }\n      });\n\n      var nativeProps = _objectSpread(_objectSpread({}, omit(this.props, ['source', 'onPlaybackStatusUpdate', 'usePoster', 'posterSource', 'posterStyle'].concat(_toConsumableArray(Object.keys(status))))), {}, {\n        style: StyleSheet.flatten([_STYLES.base, this.props.style]),\n        source: source,\n        resizeMode: nativeResizeMode,\n        status: status,\n        onStatusUpdate: this._nativeOnPlaybackStatusUpdate,\n        onLoadStart: this._nativeOnLoadStart,\n        onLoad: this._nativeOnLoad,\n        onError: this._nativeOnError,\n        onReadyForDisplay: this._nativeOnReadyForDisplay,\n        onFullscreenUpdate: this._nativeOnFullscreenUpdate\n      });\n\n      return React.createElement(View, {\n        style: nativeProps.style,\n        pointerEvents: \"box-none\"\n      }, React.createElement(ExponentVideo, _objectSpread(_objectSpread({\n        ref: this._nativeRef\n      }, nativeProps), {}, {\n        style: _STYLES.video\n      })), this._renderPoster());\n    }\n  }]);\n\n  return Video;\n}(React.Component);\n\nfunction omit(props, propNames) {\n  var copied = _objectSpread({}, props);\n\n  for (var propName of propNames) {\n    delete copied[propName];\n  }\n\n  return copied;\n}\n\nObject.assign(Video.prototype, PlaybackMixin);\nexport default Video;","map":{"version":3,"mappings":"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","names":["React","assertStatusValuesInBounds","getNativeSourceAndFullInitialStatusForLoadAsync","getNativeSourceFromSource","getUnloadedStatus","PlaybackMixin","ExpoVideoManager","ExponentAV","ExponentVideo","ResizeMode","_STYLES","StyleSheet","create","base","overflow","poster","position","left","top","right","bottom","resizeMode","video","ExpoVideoManagerConstants","ExpoVideoViewManager","Video","props","_nativeRef","createRef","_onPlaybackStatusUpdate","_handleNewStatus","status","state","showPoster","isLoaded","isPlaying","positionMillis","setState","onPlaybackStatusUpdate","_performOperationAndHandleStatusAsync","operation","current","Error","handle","findNodeHandle","_setFullscreen","value","tag","setFullscreen","presentFullscreenPlayer","dismissFullscreenPlayer","getStatusAsync","getStatusForVideo","loadAsync","source","initialStatus","downloadFirst","nativeSource","fullInitialStatus","loadForVideo","unloadAsync","unloadForVideo","setStatusAsync","setStatusForVideo","replayAsync","replayVideo","shouldPlay","_nativeOnPlaybackStatusUpdate","event","nativeEvent","_nativeOnLoadStart","onLoadStart","_nativeOnLoad","onLoad","_nativeOnError","error","onError","_nativeOnReadyForDisplay","onReadyForDisplay","_nativeOnFullscreenUpdate","onFullscreenUpdate","_renderPoster","usePoster","Image","style","posterStyle","posterSource","nativeProps","nativeVideo","setNativeProps","catch","undefined","nativeResizeMode","ScaleNone","STRETCH","ScaleToFill","CONTAIN","ScaleAspectFit","COVER","ScaleAspectFill","forEach","prop","omit","Object","keys","flatten","onStatusUpdate","View","pointerEvents","ref","Component","propNames","copied","propName","assign","prototype"],"sourceRoot":"","sources":["../src/Video.tsx"],"sourcesContent":["import * as React from 'react';\nimport { findNodeHandle, Image, NativeMethods, StyleSheet, View } from 'react-native';\n\nimport {\n  assertStatusValuesInBounds,\n  getNativeSourceAndFullInitialStatusForLoadAsync,\n  getNativeSourceFromSource,\n  getUnloadedStatus,\n  Playback,\n  PlaybackMixin,\n  AVPlaybackSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  AVPlaybackTolerance,\n} from './AV';\nimport ExpoVideoManager from './ExpoVideoManager';\nimport ExponentAV from './ExponentAV';\nimport ExponentVideo from './ExponentVideo';\nimport {\n  ExponentVideoComponent,\n  VideoFullscreenUpdateEvent,\n  VideoNativeProps,\n  VideoProps,\n  VideoReadyForDisplayEvent,\n  ResizeMode,\n  VideoState,\n} from './Video.types';\n\nconst _STYLES = StyleSheet.create({\n  base: {\n    overflow: 'hidden',\n  },\n  poster: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    resizeMode: 'contain',\n  },\n  video: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n\n// On a real device UIManager should be present, however when running offline tests with jest-expo\n// we have to use the provided native module mock to access constants\nconst ExpoVideoManagerConstants = ExpoVideoManager;\nconst ExpoVideoViewManager = ExpoVideoManager;\n\nclass Video extends React.Component<VideoProps, VideoState> implements Playback {\n  _nativeRef = React.createRef<InstanceType<ExponentVideoComponent> & NativeMethods>();\n  _onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null;\n\n  constructor(props: VideoProps) {\n    super(props);\n    this.state = {\n      showPoster: !!props.usePoster,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  setNativeProps(nativeProps: VideoNativeProps) {\n    const nativeVideo = this._nativeRef.current;\n    if (!nativeVideo) throw new Error(`native video reference is not defined.`);\n    nativeVideo.setNativeProps(nativeProps);\n  }\n\n  // Internal methods\n\n  _handleNewStatus = (status: AVPlaybackStatus) => {\n    if (\n      this.state.showPoster &&\n      status.isLoaded &&\n      (status.isPlaying || status.positionMillis !== 0)\n    ) {\n      this.setState({ showPoster: false });\n    }\n\n    if (this.props.onPlaybackStatusUpdate) {\n      this.props.onPlaybackStatusUpdate(status);\n    }\n    if (this._onPlaybackStatusUpdate) {\n      this._onPlaybackStatusUpdate(status);\n    }\n  };\n\n  _performOperationAndHandleStatusAsync = async (\n    operation: (tag: number) => Promise<AVPlaybackStatus>\n  ): Promise<AVPlaybackStatus> => {\n    const video = this._nativeRef.current;\n    if (!video) {\n      throw new Error(`Cannot complete operation because the Video component has not yet loaded`);\n    }\n\n    const handle = findNodeHandle(this._nativeRef.current)!;\n    const status: AVPlaybackStatus = await operation(handle);\n    this._handleNewStatus(status);\n    return status;\n  };\n\n  // Fullscreening API\n\n  _setFullscreen = async (value: boolean): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExpoVideoViewManager.setFullscreen(tag, value)\n    );\n  };\n\n  /**\n   * This presents a fullscreen view of your video component on top of your app's UI. Note that even if `useNativeControls` is set to `false`,\n   * native controls will be visible in fullscreen mode.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished presenting,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  presentFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(true);\n  };\n\n  /**\n   * This dismisses the fullscreen video view.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the video once the fullscreen player has finished dismissing,\n   * or rejects if there was an error, or if this was called on an Android device.\n   */\n  dismissFullscreenPlayer = async (): Promise<AVPlaybackStatus> => {\n    return this._setFullscreen(false);\n  };\n\n  // ### Unified playback API ### (consistent with Audio.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  /**\n   * @hidden\n   */\n  getStatusAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.getStatusForVideo(tag)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  loadAsync = async (\n    source: AVPlaybackSource,\n    initialStatus: AVPlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<AVPlaybackStatus> => {\n    const { nativeSource, fullInitialStatus } =\n      await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.loadForVideo(tag, nativeSource, fullInitialStatus)\n    );\n  };\n\n  /**\n   * Equivalent to setting URI to `null`.\n   * @hidden\n   */\n  unloadAsync = async (): Promise<AVPlaybackStatus> => {\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.unloadForVideo(tag)\n    );\n  };\n\n  componentWillUnmount() {\n    // Auto unload video to perform necessary cleanup safely\n    this.unloadAsync().catch(() => {\n      // Ignored rejection. Sometimes the unloadAsync code is executed when video is already unloaded.\n      // In such cases, it throws:\n      // \"[Unhandled promise rejection: Error: Invalid view returned from registry,\n      //  expecting EXVideo, got: (null)]\"\n    });\n  }\n\n  /**\n   * Set status API, only available while `isLoaded = true`.\n   * @hidden\n   */\n  setStatusAsync = async (status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus> => {\n    assertStatusValuesInBounds(status);\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.setStatusForVideo(tag, status)\n    );\n  };\n\n  /**\n   * @hidden\n   */\n  replayAsync = async (status: AVPlaybackStatusToSet = {}): Promise<AVPlaybackStatus> => {\n    if (status.positionMillis && status.positionMillis !== 0) {\n      throw new Error('Requested position after replay has to be 0.');\n    }\n\n    return this._performOperationAndHandleStatusAsync((tag: number) =>\n      ExponentAV.replayVideo(tag, {\n        ...status,\n        positionMillis: 0,\n        shouldPlay: true,\n      })\n    );\n  };\n\n  /**\n   * Sets a function to be called regularly with the `AVPlaybackStatus` of the playback object.\n   *\n   * `onPlaybackStatusUpdate` will be called whenever a call to the API for this playback object completes\n   * (such as `setStatusAsync()`, `getStatusAsync()`, or `unloadAsync()`), nd will also be called at regular intervals\n   * while the media is in the loaded state.\n   *\n   * Set `progressUpdateIntervalMillis` via `setStatusAsync()` or `setProgressUpdateIntervalAsync()` to modify\n   * the interval with which `onPlaybackStatusUpdate` is called while loaded.\n   *\n   * @param onPlaybackStatusUpdate A function taking a single parameter `AVPlaybackStatus`.\n   */\n  setOnPlaybackStatusUpdate(onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  // Methods of the Playback interface that are set via PlaybackMixin\n  playAsync!: () => Promise<AVPlaybackStatus>;\n  playFromPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  pauseAsync!: () => Promise<AVPlaybackStatus>;\n  stopAsync!: () => Promise<AVPlaybackStatus>;\n  setPositionAsync!: (\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ) => Promise<AVPlaybackStatus>;\n  setRateAsync!: (rate: number, shouldCorrectPitch: boolean) => Promise<AVPlaybackStatus>;\n  setVolumeAsync!: (volume: number) => Promise<AVPlaybackStatus>;\n  setIsMutedAsync!: (isMuted: boolean) => Promise<AVPlaybackStatus>;\n  setIsLoopingAsync!: (isLooping: boolean) => Promise<AVPlaybackStatus>;\n  setProgressUpdateIntervalAsync!: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<AVPlaybackStatus>;\n\n  // Callback wrappers\n\n  _nativeOnPlaybackStatusUpdate = (event: { nativeEvent: AVPlaybackStatus }) => {\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  // TODO make sure we are passing the right stuff\n  _nativeOnLoadStart = () => {\n    if (this.props.onLoadStart) {\n      this.props.onLoadStart();\n    }\n  };\n\n  _nativeOnLoad = (event: { nativeEvent: AVPlaybackStatus }) => {\n    if (this.props.onLoad) {\n      this.props.onLoad(event.nativeEvent);\n    }\n    this._handleNewStatus(event.nativeEvent);\n  };\n\n  _nativeOnError = (event: { nativeEvent: { error: string } }) => {\n    const error: string = event.nativeEvent.error;\n    if (this.props.onError) {\n      this.props.onError(error);\n    }\n    this._handleNewStatus(getUnloadedStatus(error));\n  };\n\n  _nativeOnReadyForDisplay = (event: { nativeEvent: VideoReadyForDisplayEvent }) => {\n    if (this.props.onReadyForDisplay) {\n      this.props.onReadyForDisplay(event.nativeEvent);\n    }\n  };\n\n  _nativeOnFullscreenUpdate = (event: { nativeEvent: VideoFullscreenUpdateEvent }) => {\n    if (this.props.onFullscreenUpdate) {\n      this.props.onFullscreenUpdate(event.nativeEvent);\n    }\n  };\n\n  _renderPoster = () =>\n    this.props.usePoster && this.state.showPoster ? (\n      <Image style={[_STYLES.poster, this.props.posterStyle]} source={this.props.posterSource!} />\n    ) : null;\n\n  render() {\n    const source = getNativeSourceFromSource(this.props.source) || undefined;\n\n    let nativeResizeMode = ExpoVideoManagerConstants.ScaleNone;\n    if (this.props.resizeMode) {\n      const resizeMode = this.props.resizeMode;\n      if (resizeMode === ResizeMode.STRETCH) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleToFill;\n      } else if (resizeMode === ResizeMode.CONTAIN) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFit;\n      } else if (resizeMode === ResizeMode.COVER) {\n        nativeResizeMode = ExpoVideoManagerConstants.ScaleAspectFill;\n      }\n    }\n\n    // Set status via individual props\n    const status: AVPlaybackStatusToSet = { ...this.props.status };\n    [\n      'progressUpdateIntervalMillis',\n      'positionMillis',\n      'shouldPlay',\n      'rate',\n      'shouldCorrectPitch',\n      'volume',\n      'isMuted',\n      'isLooping',\n    ].forEach((prop) => {\n      if (prop in this.props) {\n        status[prop] = this.props[prop];\n      }\n    });\n\n    // Replace selected native props\n    const nativeProps: VideoNativeProps = {\n      ...omit(this.props, [\n        'source',\n        'onPlaybackStatusUpdate',\n        'usePoster',\n        'posterSource',\n        'posterStyle',\n        ...Object.keys(status),\n      ]),\n      style: StyleSheet.flatten([_STYLES.base, this.props.style]),\n      source,\n      resizeMode: nativeResizeMode,\n      status,\n      onStatusUpdate: this._nativeOnPlaybackStatusUpdate,\n      onLoadStart: this._nativeOnLoadStart,\n      onLoad: this._nativeOnLoad,\n      onError: this._nativeOnError,\n      onReadyForDisplay: this._nativeOnReadyForDisplay,\n      onFullscreenUpdate: this._nativeOnFullscreenUpdate,\n    };\n\n    return (\n      <View style={nativeProps.style} pointerEvents=\"box-none\">\n        <ExponentVideo ref={this._nativeRef} {...nativeProps} style={_STYLES.video} />\n        {this._renderPoster()}\n      </View>\n    );\n  }\n}\n\nfunction omit(props: Record<string, any>, propNames: string[]) {\n  const copied = { ...props };\n  for (const propName of propNames) {\n    delete copied[propName];\n  }\n  return copied;\n}\n\nObject.assign(Video.prototype, PlaybackMixin);\n\n// note(simek): TypeDoc cannot resolve correctly name of inline and default exported class\nexport default Video;\n"]},"metadata":{},"sourceType":"module"}
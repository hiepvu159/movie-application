{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _excluded = [\"uri\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\nimport { RecordingOptionsPresets } from \"./Audio/RecordingConstants\";\n\nfunction getPermissionWithQueryAsync(_x) {\n  return _getPermissionWithQueryAsync.apply(this, arguments);\n}\n\nfunction _getPermissionWithQueryAsync() {\n  _getPermissionWithQueryAsync = _asyncToGenerator(function* (name) {\n    if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n    try {\n      var _yield$navigator$perm = yield navigator.permissions.query({\n        name: name\n      }),\n          state = _yield$navigator$perm.state;\n\n      switch (state) {\n        case 'granted':\n          return PermissionStatus.GRANTED;\n\n        case 'denied':\n          return PermissionStatus.DENIED;\n\n        default:\n          return PermissionStatus.UNDETERMINED;\n      }\n    } catch (_unused2) {\n      return PermissionStatus.UNDETERMINED;\n    }\n  });\n  return _getPermissionWithQueryAsync.apply(this, arguments);\n}\n\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    var error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n\n  return new Promise(function (resolve, reject) {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n\n  var isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  var status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying: isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\n\nfunction setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nvar mediaRecorder = null;\nvar mediaRecorderUptimeOfLastStartResume = 0;\nvar mediaRecorderDurationAlreadyRecorded = 0;\nvar mediaRecorderIsRecording = false;\n\nfunction getAudioRecorderDurationMillis() {\n  var duration = mediaRecorderDurationAlreadyRecorded;\n\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n\n  return duration;\n}\n\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n\n  getStatusForVideo: function () {\n    var _getStatusForVideo = _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    });\n\n    function getStatusForVideo(_x2) {\n      return _getStatusForVideo.apply(this, arguments);\n    }\n\n    return getStatusForVideo;\n  }(),\n  loadForVideo: function () {\n    var _loadForVideo = _asyncToGenerator(function* (element, nativeSource, fullInitialStatus) {\n      return getStatusFromMedia(element);\n    });\n\n    function loadForVideo(_x3, _x4, _x5) {\n      return _loadForVideo.apply(this, arguments);\n    }\n\n    return loadForVideo;\n  }(),\n  unloadForVideo: function () {\n    var _unloadForVideo = _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    });\n\n    function unloadForVideo(_x6) {\n      return _unloadForVideo.apply(this, arguments);\n    }\n\n    return unloadForVideo;\n  }(),\n  setStatusForVideo: function () {\n    var _setStatusForVideo = _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    });\n\n    function setStatusForVideo(_x7, _x8) {\n      return _setStatusForVideo.apply(this, arguments);\n    }\n\n    return setStatusForVideo;\n  }(),\n  replayVideo: function () {\n    var _replayVideo = _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    });\n\n    function replayVideo(_x9, _x10) {\n      return _replayVideo.apply(this, arguments);\n    }\n\n    return replayVideo;\n  }(),\n  setAudioMode: function () {\n    var _setAudioMode = _asyncToGenerator(function* () {});\n\n    function setAudioMode() {\n      return _setAudioMode.apply(this, arguments);\n    }\n\n    return setAudioMode;\n  }(),\n  setAudioIsEnabled: function () {\n    var _setAudioIsEnabled = _asyncToGenerator(function* () {});\n\n    function setAudioIsEnabled() {\n      return _setAudioIsEnabled.apply(this, arguments);\n    }\n\n    return setAudioIsEnabled;\n  }(),\n  getStatusForSound: function () {\n    var _getStatusForSound = _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    });\n\n    function getStatusForSound(_x11) {\n      return _getStatusForSound.apply(this, arguments);\n    }\n\n    return getStatusForSound;\n  }(),\n  loadForSound: function () {\n    var _loadForSound = _asyncToGenerator(function* (nativeSource, fullInitialStatus) {\n      var source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n      var media = new Audio(source);\n\n      media.ontimeupdate = function () {\n        SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n          key: media,\n          status: getStatusFromMedia(media)\n        });\n      };\n\n      media.onerror = function () {\n        SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n          key: media,\n          error: media.error.message\n        });\n      };\n\n      var status = setStatusForMedia(media, fullInitialStatus);\n      return [media, status];\n    });\n\n    function loadForSound(_x12, _x13) {\n      return _loadForSound.apply(this, arguments);\n    }\n\n    return loadForSound;\n  }(),\n  unloadForSound: function () {\n    var _unloadForSound = _asyncToGenerator(function* (element) {\n      element.pause();\n      element.removeAttribute('src');\n      element.load();\n      return getStatusFromMedia(element);\n    });\n\n    function unloadForSound(_x14) {\n      return _unloadForSound.apply(this, arguments);\n    }\n\n    return unloadForSound;\n  }(),\n  setStatusForSound: function () {\n    var _setStatusForSound = _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    });\n\n    function setStatusForSound(_x15, _x16) {\n      return _setStatusForSound.apply(this, arguments);\n    }\n\n    return setStatusForSound;\n  }(),\n  replaySound: function () {\n    var _replaySound = _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    });\n\n    function replaySound(_x17, _x18) {\n      return _replaySound.apply(this, arguments);\n    }\n\n    return replaySound;\n  }(),\n  getAudioRecordingStatus: function () {\n    var _getAudioRecordingStatus = _asyncToGenerator(function* () {\n      var _mediaRecorder, _mediaRecorder2, _mediaRecorder3;\n\n      return {\n        canRecord: ((_mediaRecorder = mediaRecorder) == null ? void 0 : _mediaRecorder.state) === 'recording' || ((_mediaRecorder2 = mediaRecorder) == null ? void 0 : _mediaRecorder2.state) === 'inactive',\n        isRecording: ((_mediaRecorder3 = mediaRecorder) == null ? void 0 : _mediaRecorder3.state) === 'recording',\n        isDoneRecording: false,\n        durationMillis: getAudioRecorderDurationMillis(),\n        uri: null\n      };\n    });\n\n    function getAudioRecordingStatus() {\n      return _getAudioRecordingStatus.apply(this, arguments);\n    }\n\n    return getAudioRecordingStatus;\n  }(),\n  prepareAudioRecorder: function () {\n    var _prepareAudioRecorder = _asyncToGenerator(function* (options) {\n      if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n        throw new Error('No media devices available');\n      }\n\n      mediaRecorderUptimeOfLastStartResume = 0;\n      mediaRecorderDurationAlreadyRecorded = 0;\n      var stream = yield getUserMedia({\n        audio: true\n      });\n      mediaRecorder = new window.MediaRecorder(stream, (options == null ? void 0 : options.web) || RecordingOptionsPresets.HIGH_QUALITY.web);\n      mediaRecorder.addEventListener('pause', function () {\n        mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n        mediaRecorderIsRecording = false;\n      });\n      mediaRecorder.addEventListener('resume', function () {\n        mediaRecorderUptimeOfLastStartResume = Date.now();\n        mediaRecorderIsRecording = true;\n      });\n      mediaRecorder.addEventListener('start', function () {\n        mediaRecorderUptimeOfLastStartResume = Date.now();\n        mediaRecorderDurationAlreadyRecorded = 0;\n        mediaRecorderIsRecording = true;\n      });\n      mediaRecorder.addEventListener('stop', function () {\n        mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n        mediaRecorderIsRecording = false;\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n      });\n\n      var _yield$this$getAudioR = yield this.getAudioRecordingStatus(),\n          uri = _yield$this$getAudioR.uri,\n          status = _objectWithoutProperties(_yield$this$getAudioR, _excluded);\n\n      return {\n        uri: null,\n        status: status\n      };\n    });\n\n    function prepareAudioRecorder(_x19) {\n      return _prepareAudioRecorder.apply(this, arguments);\n    }\n\n    return prepareAudioRecorder;\n  }(),\n  startAudioRecording: function () {\n    var _startAudioRecording = _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n\n      if (mediaRecorder.state === 'paused') {\n        mediaRecorder.resume();\n      } else {\n        mediaRecorder.start();\n      }\n\n      return this.getAudioRecordingStatus();\n    });\n\n    function startAudioRecording() {\n      return _startAudioRecording.apply(this, arguments);\n    }\n\n    return startAudioRecording;\n  }(),\n  pauseAudioRecording: function () {\n    var _pauseAudioRecording = _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n\n      mediaRecorder.pause();\n      return this.getAudioRecordingStatus();\n    });\n\n    function pauseAudioRecording() {\n      return _pauseAudioRecording.apply(this, arguments);\n    }\n\n    return pauseAudioRecording;\n  }(),\n  stopAudioRecording: function () {\n    var _stopAudioRecording = _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n\n      if (mediaRecorder.state === 'inactive') {\n        return this.getAudioRecordingStatus();\n      }\n\n      var dataPromise = new Promise(function (resolve) {\n        return mediaRecorder.addEventListener('dataavailable', function (e) {\n          return resolve(e.data);\n        });\n      });\n      mediaRecorder.stop();\n      var data = yield dataPromise;\n      var url = URL.createObjectURL(data);\n      return _objectSpread(_objectSpread({}, yield this.getAudioRecordingStatus()), {}, {\n        uri: url\n      });\n    });\n\n    function stopAudioRecording() {\n      return _stopAudioRecording.apply(this, arguments);\n    }\n\n    return stopAudioRecording;\n  }(),\n  unloadAudioRecorder: function () {\n    var _unloadAudioRecorder = _asyncToGenerator(function* () {\n      mediaRecorder = null;\n    });\n\n    function unloadAudioRecorder() {\n      return _unloadAudioRecorder.apply(this, arguments);\n    }\n\n    return unloadAudioRecorder;\n  }(),\n  getPermissionsAsync: function () {\n    var _getPermissionsAsync = _asyncToGenerator(function* () {\n      var maybeStatus = yield getPermissionWithQueryAsync('microphone');\n\n      switch (maybeStatus) {\n        case PermissionStatus.GRANTED:\n          return {\n            status: PermissionStatus.GRANTED,\n            expires: 'never',\n            canAskAgain: true,\n            granted: true\n          };\n\n        case PermissionStatus.DENIED:\n          return {\n            status: PermissionStatus.DENIED,\n            expires: 'never',\n            canAskAgain: true,\n            granted: false\n          };\n\n        default:\n          return yield this.requestPermissionsAsync();\n      }\n    });\n\n    function getPermissionsAsync() {\n      return _getPermissionsAsync.apply(this, arguments);\n    }\n\n    return getPermissionsAsync;\n  }(),\n  requestPermissionsAsync: function () {\n    var _requestPermissionsAsync = _asyncToGenerator(function* () {\n      try {\n        var stream = yield getUserMedia({\n          audio: true\n        });\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true\n        };\n      } catch (_unused) {\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false\n        };\n      }\n    });\n\n    function requestPermissionsAsync() {\n      return _requestPermissionsAsync.apply(this, arguments);\n    }\n\n    return requestPermissionsAsync;\n  }()\n};","map":{"version":3,"mappings":"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","names":["PermissionStatus","SyntheticPlatformEmitter","RecordingOptionsPresets","getPermissionWithQueryAsync","name","navigator","permissions","query","state","GRANTED","DENIED","UNDETERMINED","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","play","pause","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","element","loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","setStatusForVideo","replayVideo","setAudioMode","setAudioIsEnabled","getStatusForSound","loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","removeAttribute","load","setStatusForSound","replaySound","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","options","stream","audio","window","MediaRecorder","web","HIGH_QUALITY","addEventListener","getTracks","forEach","track","stop","startAudioRecording","resume","start","pauseAudioRecording","stopAudioRecording","dataPromise","e","data","url","URL","createObjectURL","unloadAudioRecorder","getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync"],"sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): AVPlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"]},"metadata":{},"sourceType":"module"}